#binary search program for freestyle job.
import argparse
from typing import List, Optional

def binary_search_iterative(arr: List[int], target: int) -> Optional[int]:
    """Standard iterative binary search.
    Returns the index of target in arr, or None if not found.
    Assumes arr is sorted ascending.
    """
    lo, hi = 0, len(arr) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if arr[mid] == target:
            return mid
        if arr[mid] < target:
            lo = mid + 1
        else:
            hi = mid - 1
    return None


def binary_search_recursive(arr: List[int], target: int, lo: int = 0, hi: Optional[int] = None) -> Optional[int]:
    """Recursive binary search wrapper."""
    if hi is None:
        hi = len(arr) - 1
    if lo > hi:
        return None
    mid = (lo + hi) // 2
    if arr[mid] == target:
        return mid
    if arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, hi)
    return binary_search_recursive(arr, target, lo, mid - 1)


def parse_list(s: str, sep: str) -> List[int]:
    parts = [p for p in (s.split(sep) if sep != ',' else s.split(',')) if p.strip() != ""]
    return [int(x) for x in parts]


def main():
    parser = argparse.ArgumentParser(description="Binary search example")
    parser.add_argument("--list", "-l", type=str, help="Sorted list of integers (comma or custom-separated). Example: '1,3,5' or '1 3 5'")
    parser.add_argument("--sep", "-s", type=str, default=",", help="Separator used in --list (default: ','). Use ' ' for spaces.")
    parser.add_argument("--target", "-t", type=int, help="Target integer to search for")
    parser.add_argument("--method", "-m", choices=["iterative", "recursive"], default="iterative", help="Search method (default: iterative)")
    args = parser.parse_args()

    if not args.list or args.target is None:
        # Demo run
        demo = [1, 3, 5, 7, 9, 11, 13]
        for tgt in (5, 6, 13, 1, 14):
            idx = binary_search_iterative(demo, tgt)
            print(f"Searching {tgt} in {demo} -> index: {idx}")
        return

    arr = parse_list(args.list, args.sep)
    arr.sort() 
    target = args.target

    if args.method == "iterative":
        idx = binary_search_iterative(arr, target)
    else:
        idx = binary_search_recursive(arr, target)

    if idx is None:
        print(f"{target} not found in {arr}")
    else:
        print(f"{target} found at index {idx} in {arr}")


if __name__ == "__main__":
    main()
